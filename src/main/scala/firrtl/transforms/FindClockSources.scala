// See LICENSE for license details.

package firrtl.transforms

import firrtl.analyses._
import firrtl.annotations.TargetToken._
import firrtl.annotations._
import firrtl.{CircuitForm, CircuitState, FEMALE, MALE, MemKind, MidForm, PortKind, RegKind, RenameMap, Transform}
import firrtl.ir._

import scala.collection.mutable

/** Finds clock sources of specific signals
  *
  * For all targets contained within a [[GetClockSources]] annotation, calculate their clock source
  * Produces a [[ClockSources]] annotation containing their mapping
  *
  * If target is:
  *   - ReferenceTarget; calculate clock source
  *   - InstanceTarget; calculate clock source of all input ports to that instance
  *   - ModuleTarget; calculate clock source of all output ports
  *   - CircuitTarget; calculate clock source of all output ports of all modules
  */
class FindClockSources() extends Transform {

  override def inputForm: CircuitForm = MidForm
  override def outputForm: CircuitForm = MidForm

  override def execute(state: CircuitState): CircuitState = {

    val targets = state.annotations.flatMap {
      case GetClockSources(targets) => targets
    }

    if(targets.nonEmpty) {
      val finder = new ClockSourceFinder(CircuitGraph(state.circuit))
      val signalToClockSources = finder.getClockSource(targets).map { case (signal, sources) =>
        signal -> sources.map {
          case c: ReferenceTarget if CircuitGraph.isAsClock(c) => (c.moduleTarget: IsMember, Some(c.ref))
          case c: ReferenceTarget => (c, None)
        }
      }
      state.copy(annotations = ClockSources(signalToClockSources) +: state.annotations)
    } else {
      state
    }
  }
}

/** Consumed by [[FindClockSources]], records a given set of signals for which to find their clock sources
  * @param targets
  */
case class GetClockSources(targets: Seq[CompleteTarget]) extends Annotation {
  override def update(renames: RenameMap): Seq[Annotation] = {
    val newTargets = targets.flatMap(renames(_))
    Seq(GetClockSources(newTargets))
  }
}

/** Generated by [[FindClockSources]], maps a given clock source to signals that are synchronized with it
  */
case class ClockSources(signalToClocks: Map[ReferenceTarget, Set[(IsMember, Option[String])]]) extends Annotation {
  override def update(renames: RenameMap): Seq[Annotation] = {
    val newSignalToClocks = signalToClocks.flatMap { case (signal, sources) =>
      val newSignals = renames(signal).collect {
        case x: ReferenceTarget => x
        case other => sys.error("Don't make my signals not a ReferenceTarget!")
      }

      val newClockSources = sources.map { case (clockSource, isAsClock) =>
        renames.get(clockSource) match {
          case Some(Seq(x: IsMember)) => (x, isAsClock)
          case None => (clockSource, isAsClock)
          case other => sys.error("Don't split or delete my clock source!!")
        }
      }
      newSignals.map(s => s -> newClockSources)
    }
    Seq(ClockSources(newSignalToClocks))
  }
}


/** Instance-Viewed Graph to find clock sources of signals */
class ClockSourceFinder(graph: CircuitGraph) extends CircuitGraph(graph.circuit, graph.digraph.reverse, graph.irLookup) {

  /** Finds clock sources of specific signals
    *
    * If target is:
    *   - ReferenceTarget; calculate clock source, must be ground type
    *   - InstanceTarget; calculate clock source of all input ports to that instance
    *   - ModuleTarget; calculate clock source of all output ports
    *   - CircuitTarget; calculate clock source of all output ports of all modules
    *
    * @param targets
    * @return
    */
  def getClockSource(targets: Seq[CompleteTarget]): Map[ReferenceTarget, Set[ReferenceTarget]] = {
    val memberTargets: Seq[IsMember] = targets.flatMap {
      case ct: CircuitTarget => graph.circuit.modules.map(m => ct.module(m.name))
      case other: IsMember => Seq(other)
    }.distinct

    val moduleOrder = new InstanceGraph(circuit).moduleOrder.zipWithIndex.map {
      case (m, i) => m.name -> i
    }.toMap

    val topoTargets = memberTargets.sortWith { (t0, t1) =>
      (t0, t1) match {
        case (x: CircuitTarget, _) => false
        case (_, x: CircuitTarget) => true
        case (x: IsMember, y: IsMember) => moduleOrder(x.module) > moduleOrder(y.module)
      }
    }

    val ret = topoTargets.foldLeft(Map.empty[ReferenceTarget, Set[ReferenceTarget]]) { (map, t) =>
      t match {
        case it: InstanceTarget =>
          val lit = it.asReference.pathlessTarget
          val inputTargets = irLookup.leafTargets(lit).collect {
            case r if irLookup.gender(r) == FEMALE => r
          }
          inputTargets.foldLeft(map){ (m, inTarget) =>
            val x = it.addReference(inTarget)
            m ++ Map(x -> getClockSource(x))
          }
        case rt: ReferenceTarget => map ++ Map(rt -> getClockSource(rt))
        case mt: ModuleTarget =>
          val outputTargets = irLookup.ports(mt).flatMap { irLookup.leafTargets }.collect {
            case r if irLookup.gender(r) == FEMALE => r
          }
          outputTargets.foldLeft(map) { (m, ot) => m ++ Map(ot -> getClockSource(ot)) }
      }
    }
    ret
  }

  /** Returns the clock sources that are synchronized with given signal target
    * @param t
    * @return
    */
  def getClockSource(t: ReferenceTarget): Set[ReferenceTarget] = {
    require(
      irLookup.contains(t),
      s"Cannot find\n${t.prettyPrint()}\nin circuit, when computing its clock source!"
    )

    val tpe = irLookup.tpe(t)
    //require(
    //  tpe.isInstanceOf[GroundType],
    //  s"Cannot compute clock source of\n${t.prettyPrint()}\nwith type ${tpe.serialize}!"
    //)

    val finalSources = mutable.HashSet.empty[ReferenceTarget]
    IRLookup.leafTargets(t, tpe).foreach { x =>
      prioritySearch(x, Set.empty[ReferenceTarget])(
        new Ordering[ReferenceTarget]{
          override def compare(x: ReferenceTarget, y: ReferenceTarget): Int = x.path.size - y.path.size
        }
      )
      finalSources ++= clockMap.getOrElse(x, mutable.HashSet.empty[ReferenceTarget])
    }

    //val finalSources = clockMap.getOrElse(t, mutable.HashSet.empty[ReferenceTarget])
    finalSources.toSet
  }

  private val extModuleNames = circuit.modules.collect { case e: ExtModule => e.name }.toSet

  // Maps signal to set of clock sources it is synchronized with
  private val clockMap = mutable.HashMap[ReferenceTarget, mutable.HashSet[ReferenceTarget]]()

  // Utility function to determine if a target is a register
  private def isReg(t: ReferenceTarget): Boolean = {
    t.tryToComplete match {
      case rt: ReferenceTarget if !rt.isClock && !rt.isInit && !rt.isReset && irLookup.kind(t) == RegKind => true
      case other => false
    }
  }

  private def update(node: ReferenceTarget, clocks: Iterable[ReferenceTarget]): Unit =
    clockMap.getOrElseUpdate(node, mutable.HashSet.empty[ReferenceTarget]) ++= clocks

  private def recordClock(source: ReferenceTarget, prevOpt: Option[collection.Map[ReferenceTarget, ReferenceTarget]])
                         (clock: ReferenceTarget): Unit = recordClocks(source, prevOpt)(Set(clock))

  private def recordClocks(source: ReferenceTarget, prevOpt: Option[collection.Map[ReferenceTarget, ReferenceTarget]])
                          (clocks: collection.Set[ReferenceTarget]): Unit = {
    val perModuleClocks = mutable.HashMap[String, mutable.HashSet[ReferenceTarget]]()

    def updatePerModuleClocks(clk: ReferenceTarget): Unit = {
      perModuleClocks.getOrElseUpdate(clk.module, mutable.HashSet.empty[ReferenceTarget]) += clk
      if(clk.path.nonEmpty) {
        updatePerModuleClocks(clk.stripHierarchy(1))
      }
    }

    clocks.foreach { clk => updatePerModuleClocks(clk) }

    val nodePath = new mutable.ArrayBuffer[ReferenceTarget]()
    nodePath += source
    val prev = prevOpt.get
    while (prev.contains(nodePath.last)) {
      val x = nodePath.last
      perModuleClocks.get(x.encapsulatingModule) match {
        case Some(clks) => update(x.pathlessTarget, clks)
        case None =>
      }
      nodePath += prev(nodePath.last)
    }
    clockMap.getOrElseUpdate(nodePath.last, mutable.HashSet.empty[ReferenceTarget]) ++= clocks
  }

  /** Returns instance-viewed combinational-edges or reg-to-clock edges
    * Ends early if visiting a node that was previously visited in another BFS
    * @param source the specified node
    * @param prevOpt
    * @return a Set[T] of all vertices that source has edges to
    */
  override def getEdges(source: ReferenceTarget, prevOpt: Option[collection.Map[ReferenceTarget, ReferenceTarget]]): collection.Set[ReferenceTarget] = {

    val superEdges = super.getEdges(source)

    val instanceEdges = super.getShortCutEdges(source, superEdges)

    val filteredEdges = instanceEdges.flatMap {
      // If is is a combinational read-memory, return non-clock signals, otherwise return only clock signals
      case rt: ReferenceTarget
        if irLookup.kind(source) == MemKind && irLookup.gender(source) == MALE =>
          (irLookup.declaration(source).asInstanceOf[DefMemory].readLatency, rt.component.last.value) match {
            case (0, "clk") => Seq()
            case (0, _) => Seq(rt)
            case (_, "clk") => Seq(rt)
            case (_, _) => Seq()
          }
      // Is a Register, filter non-clock outgoing edges
      case rt: ReferenceTarget
        if isReg(source) && (rt.tokens.last != Clock) =>
        Seq()
      case other => Seq(other)
    }

    val shortCutEdges = filteredEdges.flatMap {
      // If seen node before, record clock and end
      case e if clockMap.contains(e) =>
        recordClocks(source, prevOpt)(clockMap(e))
        Seq()
      // If seen node before but with child root, return clock sources with added hierarchy
      case e: ReferenceTarget if e.path.nonEmpty && clockMap.contains(e.stripHierarchy(1)) =>
        clockMap(e.stripHierarchy(1)).map(_.addHierarchy(e.module, e.path.head._1.value))
      // If source is exiting to parent, record clock source for AST module but also return
      case e => Seq(e)
    }

    val ret = shortCutEdges.flatMap {
      // Top-level Input Port
      // Must check if not isClock because expression that is in the clock port of reg could be a port
      case rt@ ReferenceTarget(c, m, Nil, _, _)
        if irLookup.kind(rt) == PortKind && irLookup.gender(rt) == MALE && !rt.isClock =>
        recordClock(source, prevOpt)(rt)
        Seq()
      // Black-box Output Clock Port
      case rt: ReferenceTarget
        if extModuleNames.contains(rt.encapsulatingModule) && irLookup.tpe(rt) == ClockType && irLookup.gender(rt) == FEMALE =>
        recordClock(source, prevOpt)(rt)
        Seq()
      // AsClock Expression
      case ct if CircuitGraph.isAsClock(ct) =>
        recordClock(source, prevOpt)(ct)
        Seq()
      case other => Seq(other)
    }

    ret
  }
}
