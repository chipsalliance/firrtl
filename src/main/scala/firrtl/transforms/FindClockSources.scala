// See LICENSE for license details.

package firrtl.transforms

import firrtl.analyses._
import firrtl.annotations.TargetToken._
import firrtl.annotations._
import firrtl.{CircuitForm, CircuitState, FEMALE, MALE, MemKind, MidForm, PortKind, RegKind, RenameMap, Transform}
import firrtl.ir._

import scala.collection.mutable

/** Finds clock sources of specific signals
  *
  * For all targets contained within a [[GetClockSources]] annotation, calculate their clock source
  * Produces a [[ClockSources]] annotation containing their mapping
  *
  * If target is:
  *   - ReferenceTarget; calculate clock source
  *   - InstanceTarget; calculate clock source of all input ports to that instance
  *   - ModuleTarget; calculate clock source of all output ports
  *   - CircuitTarget; calculate clock source of all output ports of all modules
  */
class FindClockSources() extends Transform {

  override def inputForm: CircuitForm = MidForm
  override def outputForm: CircuitForm = MidForm

  override def execute(state: CircuitState): CircuitState = {

    val targets = mutable.ArrayBuffer.empty[CompleteTarget]
    val signalsToClocks = mutable.HashMap.empty[ReferenceTarget, Set[ReferenceTarget]]
    state.annotations.foreach {
      case GetClockSources(ts) => targets ++= ts
      case cs: ClockSources => signalsToClocks ++= cs.signalsToClockRefs
      case other =>
    }

    if(targets.nonEmpty) {
      val finder = new ClockSourceFinder(ConnectionGraph(state.circuit), signalsToClocks.toMap)
      val clockSources = ClockSources.buildFromRefs(finder.getClockSource(targets))
      state.copy(annotations = clockSources +: state.annotations)
    } else {
      state
    }
  }
}

/** Consumed by [[FindClockSources]], records a given set of signals for which to find their clock sources
  * @param targets
  */
case class GetClockSources(targets: Seq[CompleteTarget]) extends Annotation {
  override def update(renames: RenameMap): Seq[Annotation] = {
    val newTargets = targets.flatMap(renames(_))
    Seq(GetClockSources(newTargets))
  }
}

object ClockSources {
  def buildFromRefs(signalToClockRefs: Map[ReferenceTarget, Set[ReferenceTarget]]): ClockSources = {
    val signalToClockSources = signalToClockRefs.map { case (signal, sources) =>
      signal -> sources.map {
        case c: ReferenceTarget if ConnectionGraph.isAsClock(c) => (c.pathTarget: IsMember, Some(c.ref))
        case c: ReferenceTarget => (c, None)
      }
    }
    ClockSources(signalToClockSources)
  }
}

/** Generated by [[FindClockSources]], maps a given clock source to signals that are synchronized with it
  */
case class ClockSources(signalToClocks: Map[ReferenceTarget, Set[(IsMember, Option[String])]]) extends Annotation {
  override def update(renames: RenameMap): Seq[Annotation] = {
    val newSignalToClocks = signalToClocks.flatMap { case (signal, sources) =>
      val newSignals = renames(signal).collect {
        case x: ReferenceTarget => x
        case other => sys.error("Don't make my signals not a ReferenceTarget!")
      }

      val newClockSources = sources.map { case (clockSource, isAsClock) =>
        renames.get(clockSource) match {
          case Some(Seq(x: IsMember)) => (x, isAsClock)
          case None => (clockSource, isAsClock)
          case other => sys.error("Don't split or delete my clock source!!")
        }
      }
      newSignals.map(s => s -> newClockSources)
    }
    Seq(ClockSources(newSignalToClocks))
  }

  def clockToSignals: Map[Option[(IsMember, Option[String])], Seq[ReferenceTarget]] =
    signalToClocks.foldLeft(Map.empty[Option[(IsMember, Option[String])], Seq[ReferenceTarget]]){
      case (map, (signal, clocks)) if clocks.nonEmpty => clocks.foldLeft(map){ (m, clock) =>
        map + (Some(clock) -> (signal +: map.getOrElse(Some(clock), Nil)))
      }
      case (map, (signal, clocks)) if clocks.isEmpty =>
        map + (None -> (signal +: map.getOrElse(None, Nil)))
    }

  def prettyPrint: String =
    clockToSignals.map {
      case (Some((ref: ReferenceTarget, None)), seq) => "Clock Domain " + ref.toString + "\n\t" + seq.mkString("\n\t") + "\n"
      case (Some((mod: IsModule, Some(x))), seq) => "Clock Domain " + mod.ref(x) + "\n\t" + seq.mkString("\n\t") + "\n"
      case (None, seq) => "No Clock Domain" + "\n\t" + seq.mkString("\n\t") + "\n"
    }.mkString("\n")

  def signalsToClockRefs: Map[ReferenceTarget, Set[ReferenceTarget]] =
    signalToClocks.map {
      case (signal, seq) => signal -> seq.map {
        case (ref: ReferenceTarget, None) => ref
        case (mod: IsModule, Some(x: String)) => mod.ref(x)
      }
    }
}


/** Instance-Viewed Graph to find clock sources of signals */
class ClockSourceFinder(graph: ConnectionGraph,
                        signalToClocks: Map[ReferenceTarget, Set[ReferenceTarget]] = Map.empty
                       ) extends ConnectionGraph(graph.circuit, graph.digraph.reverse, graph.irLookup) {

  /** Finds clock sources of specific signals
    *
    * If target is:
    *   - ReferenceTarget; calculate clock source, must be ground type
    *   - InstanceTarget; calculate clock source of all input ports to that instance
    *   - ModuleTarget; calculate clock source of all output ports
    *   - CircuitTarget; calculate clock source of all output ports of all modules
    *
    * @param targets
    * @return
    */
  def getClockSource(targets: Seq[CompleteTarget]): Map[ReferenceTarget, Set[ReferenceTarget]] = {
    val memberTargets: Seq[IsMember] = targets.map {
      case ct: CircuitTarget => ct.module(ct.circuit)
      case other: IsMember => other
    }.distinct

    val ret = memberTargets.foldLeft(Map.empty[ReferenceTarget, Set[ReferenceTarget]]) { (map, t) =>
      t match {
        case it: InstanceTarget =>
          val lit = it.asReference.pathlessTarget

          val inputTargets = lit.leafSubTargets(irLookup.tpe(lit)).collect {
            case r if irLookup.gender(r) == FEMALE => r
          }
          inputTargets.foldLeft(map){ (m, inTarget) =>
            val x = it.addReference(inTarget)
            m ++ Map(x -> getClockSource(x))
          }
        case rt: ReferenceTarget => map ++ Map(rt -> getClockSource(rt))
        case mt: ModuleTarget =>
          val outputTargets = irLookup.ports(mt).flatMap { irLookup.leafTargets }.collect {
            case r if irLookup.gender(r) == FEMALE => r
          }
          outputTargets.foldLeft(map) { (m, ot) => m ++ Map(ot -> getClockSource(ot)) }
      }
    }
    ret
  }

  /** Returns the clock sources that are synchronized with given signal target
    * @param t
    * @return
    */
  def getClockSource(t: ReferenceTarget): Set[ReferenceTarget] = {
    require(
      irLookup.contains(t),
      s"Cannot find\n${t.prettyPrint()}\nin circuit, when computing its clock source!"
    )

    val tpe = irLookup.tpe(t)

    val finalSources = mutable.HashSet.empty[ReferenceTarget]
    t.leafSubTargets(tpe).foreach { x =>
      BFS(x, Set.empty[ReferenceTarget])
      finalSources ++= clockMap.getOrElse(x, mutable.HashSet.empty[ReferenceTarget])
    }
    finalSources.toSet
  }

  private val extModuleNames = circuit.modules.collect { case e: ExtModule => e.name }.toSet

  // Maps signal to set of clock sources it is synchronized with
  private val clockMap = mutable.HashMap[ReferenceTarget, mutable.HashSet[ReferenceTarget]]()
  signalToClocks.foreach { case (signal, clocks) =>
    clockMap.getOrElseUpdate(signal, mutable.HashSet.empty[ReferenceTarget]) ++= clocks
  }

  // Utility function to determine if a target is a register
  private def isReg(t: ReferenceTarget): Boolean = {
    t.tryToComplete match {
      case rt: ReferenceTarget if !rt.isClock && !rt.isInit && !rt.isReset && irLookup.kind(t) == RegKind => true
      case other => false
    }
  }

  private def recordClock(source: ReferenceTarget, prevOpt: Option[collection.Map[ReferenceTarget, ReferenceTarget]])
                         (clock: ReferenceTarget): Unit = {
    recordClocks(source, prevOpt)(Set(clock))
  }

  private def recordClocks(source: ReferenceTarget, prevOpt: Option[collection.Map[ReferenceTarget, ReferenceTarget]])
                          (clocks: collection.Set[ReferenceTarget]): Unit = {
    val perModuleClocks = mutable.HashMap[String, mutable.HashSet[ReferenceTarget]]()

    def updatePerModuleClocks(clk: ReferenceTarget): Unit = {
      perModuleClocks.getOrElseUpdate(clk.module, mutable.HashSet.empty[ReferenceTarget]) += clk
      if(clk.path.nonEmpty) {
        updatePerModuleClocks(clk.stripHierarchy(1))
      }
    }

    clocks.foreach { clk => updatePerModuleClocks(clk) }

    val nodePath = new mutable.ArrayBuffer[ReferenceTarget]()
    nodePath += source
    val prev = prevOpt.get
    while (prev.contains(nodePath.last)) {
      val x = nodePath.last
      perModuleClocks.get(x.encapsulatingModule) match {
        case Some(clks) =>
          clockMap.getOrElseUpdate(x.pathlessTarget, mutable.HashSet.empty[ReferenceTarget]) ++= clks
        case None =>
      }
      nodePath += prev(nodePath.last)
    }
    clockMap.getOrElseUpdate(nodePath.last, mutable.HashSet.empty[ReferenceTarget]) ++= clocks
  }

  /** Returns instance-viewed combinational-edges or reg-to-clock edges
    * Ends early if visiting a node that was previously visited in another BFS
    * @param source the specified node
    * @param prevOpt
    * @return a Set[T] of all vertices that source has edges to
    */
  override def getEdges(source: ReferenceTarget,
                        prevOpt: Option[collection.Map[ReferenceTarget, ReferenceTarget]]
                       ): collection.Set[ReferenceTarget] = {
    source match {

      // If seen node before, record clock and end
      case e if clockMap.contains(e) =>
        recordClocks(e, prevOpt)(clockMap(e))
        Set()

      // Top-level Input Port
      // Must check if not isClock because expression that is in the clock port of reg could be a port
      case rt@ ReferenceTarget(c, m, Nil, _, _)
        if irLookup.kind(rt) == PortKind && irLookup.gender(rt) == MALE && !rt.isClock =>
        recordClock(source, prevOpt)(rt)
        Set()

      // Black-box Output Clock Port
      case rt: ReferenceTarget
        if extModuleNames.contains(rt.encapsulatingModule) && irLookup.tpe(rt) == ClockType && irLookup.gender(rt) == FEMALE =>
        recordClock(source, prevOpt)(rt)
        Set()

      // AsClock Expression
      case ct if ConnectionGraph.isAsClock(ct) =>
        recordClock(source, prevOpt)(ct)
        Set()

      case nonClockSource =>

        val superEdges = super.getEdges(nonClockSource)

        //val instanceEdges = getShortCutEdges(nonClockSource, superEdges)

        val filteredEdges = superEdges.flatMap {

          // If is is a combinational read-memory, return non-clock signals, otherwise return only clock signals
          case rt: ReferenceTarget if irLookup.kind(nonClockSource) == MemKind && irLookup.gender(nonClockSource) == MALE =>
            (irLookup.declaration(nonClockSource).asInstanceOf[DefMemory].readLatency, rt.component.last.value) match {
              case (0, "clk") => Seq()
              case (0, _) => Seq(rt)
              case (_, "clk") => Seq(rt)
              case (_, _) => Seq()
            }

          // Is a Register, filter non-clock outgoing edges
          case rt: ReferenceTarget if isReg(nonClockSource) && (rt.tokens.last != Clock) => Seq()

          case other => Seq(other)
        }

        filteredEdges.toSet

    }
  }
}
